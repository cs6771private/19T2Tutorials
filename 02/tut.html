{% extends "templates/tut.html" %}
{% block questions %}

<li>
What is the difference between each kind of iterator?
<ul>
  <li>Input iterator</li>
  <li>Output iterator</li>
  <li>Forward iterator</li>
  <li>Bidirectional iterator</li>
  <li>Random-access iterator</li>
</ul>
<div class="answer">
{{ include_code("solutions/test.c") }}
</div>
</li>

<li>
What is different about a const iterator compared to a non-const iterator?
</li>

<li>
What kind of iterator is each of the following (and are the iterators const)?<br />
Which of these will compile, and which of these will not?<br />
Note: std::list is a doubly linked list, and std::forward_list is a singly linked list.<br />

<pre><code>
  const std::vector&lt;int&gt vec;
  std::list&lt;int&gt; li;
  std::forward_list&lt;double&gt; forward_li;
  std::string s;

  vec.begin();
  vec.cbegin();
  *vec.begin()++;
  li.cbegin();
  li.rbegin();
  forward_li.cbegin();
  *forward_li.cbegin()++;
  forward_li.crbegin();
  s.begin();
  std::back_inserter(vec);
  std::back_inserter(li);
  std::istream_iterator&lt;int&gt;(std::cin);
  std::ostream_iterator&lt;int&gt;(std::cout, " ");
</code></pre>

<li>
What is the relationship between containers, iterators, and algorithms?<br />
Why is this relationship so important, and how does it help us as programmers<br >
How does this relate to the DRY (don't repeat yourself) principle? 
</li>

<li>

  <ol>
    <li>Use standard algorithms to read a list of newline-seperated words from a file (try
      /usr/share/dict/words or /usr/dict/words) into a vector (hint: see std::istream_iterator)
    </li>
    <li>Write a function that:
      <ol>
        <li>Takes in the word list and a string</li>
        <li>Uses standard algorithms to split the string into words, filtered to only words that are
          in the word dict, and reconstruct this into a string (hint: see std::istringstream,
          std::istream_iterator, std::copy_if, std::ostringstream, and std::ostream_iterator)
        </li>
      </ol>
    </li>
    <li>Discuss why separating your functions you want to test is a good idea</li>
    <li>Write some tests for your code.</li>
    <li>Assume now that the word list and strings are both very large. Discuss how we could make
      this code run much faster (hint: a different data structure may be required. Tutors, students
      should know the data type, but not what it is called in C++)
    </li>
    <li>Use the algorithms library to make your code run much faster</li>
    <li>Discuss the effect the use of the algorithms library had on the quantity of the tests you
      had to change, and the depth of the testing required.
    </li>
    <li>Discuss the effect the use of automatic type deduction (through the use of auto keyword, and
      by not having to declare types at all when calling functions) on the quantity of code you had
      to change, and the depth of the testing required.
    </li>
  </ol>

  <details>
    <summary>Outline of possible solutions</summary>
  </details>
</li>
{% endblock %}
