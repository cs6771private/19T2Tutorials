{% extends "templates/tut.html" %}
{% block questions %}

<li>
  How might we use a lambda function in the following example to sort vec by the length of the strings?
  <pre>
    std::vector&lt;std::string&gt; vec{"We", "love", "lambda", "functions"};
  </pre>
  <div class="answer">
    <pre>
    std::sort(vec.begin(), vec.end(), [] (const auto& lhs, const auto& rhs) { return lhs.size() < rhs.size(); });
    </pre>
  </div>
</li>

<li>
  When writing a lambda function, when would you capture by value, and when would you capture by reference?
  <div class="answer">
    <ul>
      <li>Capture by value when the variable may change, and you want the variable at the current time</li>
      <li>Capture by value when the lifetime of the lambda may exceed the lifetime of the variable</li>
      <li>Capture by reference when the variable may change, and you want to stay updated</li>
      <li>Capture by reference when the variable is unable to be copied, or expensive to copy</li>
    </ul>
  </div>
</li>

<li>
  <ol>
    <li>Use standard algorithms to read a list of newline-seperated words from a file (try
      /usr/share/dict/words or /usr/dict/words) into a vector (hint: see std::istream_iterator)
    </li>
    <li>Write a function that:
      <ol>
        <li>Takes in the word list and a string</li>
        <li>Uses standard algorithms to split the string into words, filtered to only words that are
          in the word dict, and reconstruct this into a string (hint: see std::istringstream,
          std::istream_iterator, std::copy_if, std::ostringstream, and std::ostream_iterator)
        </li>
      </ol>
    </li>
    <li>Discuss why separating your functions you want to test is a good idea</li>
    <li>Assume now that the word list and strings are both very large. Discuss how we could make
      this code run much faster (hint: a different data structure may be required. Tutors, students
      should know the data type, but not what it is called in C++)
    </li>
    <li>Discuss the effect the use of automatic type deduction (through the use of auto keyword, and
      by not having to declare types at all when calling functions) on the quantity of code you had
      to change, and the depth of the testing required.
    </li>
  </ol>
</li>

<li>
<ol>
  <li> <strong>Open tutorials/week3/car.(cpp/h):</strong></li>
  <li>Create a constructor for the car that takes in the manufacturer name (e.g. Toyota) and the number of seats. Ensure that your constructor uses a member initializer list and uniform initialisation. Why is it important to use a member initializer list? Why is uniform initialisation prefered in C++11?</li>
  <li>Create a default constructor that delegates to the previous constructor using the values of "unknown" and 4</li>
  <li>Create const member functions to get the manufacturer and number of seats. What does it mean for a class or function to be const correct?</li>
  <li>Create a static data member to keep count of the number of car objects created. Modify your constructors to ensure that the count increases when a new object is created. Do you need to increase the object count in your delegating constructor?</li>
  <li>Ensure that your static object count is initialised to 0, where should you do this, in the header file or the cpp file?</li>
  <li>Create a static function to return the object count. What does it mean for an function or data member to be static? Is the static data member part of the object or the class?</li>
  <li>Create a destructor that decreases the object count when an object is destroyed</li>
  <li>Make sure you keep your code - this example will continue next week.</li>
</ol>

</li>
{% endblock %}
