{% extends "templates/tut.html" %}
{% block questions %}

<li>
Are you having any issues with the assignment? Any questions you want to ask your tutor?
</li>

<li>
What is the difference between each kind of iterator?
<ul>
  <li>Input iterator</li>
  <li>Output iterator</li>
  <li>Forward iterator</li>
  <li>Bidirectional iterator</li>
  <li>Random-access iterator</li>
</ul>
<div class="answer">
  <ul>
    <li>An input iterator allows read and increment. However, it cannot make multiple passes when incrementing</li>
    <li>An output iterator allows write and increment. However, it cannot make multiple passes when incrementing</li>
    <li>A forward iterator allows read, write and increment</li>
    <li>A bidirectional iterator allows read, write, increment, and decrement</li>
    <li>A random-access iterator allows read, write, increment, decrement, +x, and -x</li>
  </ul>

  Multiple passes means you can read an old value of an iterator (by copying the iterator and advancing a copy, for example).
</div>
</li>

<li>
We write some code (marks.cpp) to store information in a container and then access the middle element (to determine the median). What's wrong with this code? How could we modify this code to produce the intended result?
<pre></code>
#include <iostream>
#include <list>

int main() {
  std::list<int> studentMarks;
  studentMarks.push_back(63);
  studentMarks.push_back(67);
  studentMarks.push_back(69);
  studentMarks.push_back(74);
  studentMarks.push_back(82);

  std::cout << "Median: " << studentMarks[2] << "\n";
}
</code></pre>
<div class="answer">
  {{ include_code("solutions/marks.cpp") }}
</div>

<li>
What is different about a const iterator compared to a non-const iterator?
<div class="answer">
  A const iterator does not allow modification of the value that the iterator refers to.
</div>
</li>

<li>
Here is a C-style and C++-style method of forward iterating through an array. In each of these cases, how would we modify the code (rev.cpp) to iterate in the other direction? Why is the C++ way preferred?
{{ include_code("questions/rev.cpp") }}
<div class="answer">
  {{ include_code("solutions/rev_solution.cpp") }}
</div>

</li>

<li>
What kind of iterator is each of the following (and are the iterators const)?<br />
Which of these will compile, and which of these will not?<br />
Note: std::list is a doubly linked list, and std::forward_list is a singly linked list.<br />

{{ include_code("questions/iteratorclass.cpp") }}
<div class="answer">
  {{ include_code("solutions/iteratorclass.cpp") }}
</div>
</li>


<li>
Below are two functions sumInt and sumDouble. Use function overloading to improve the style of this code (sum.cpp)
{{ include_code("questions/overload.cpp") }}
<div class="answer">
  {{ include_code("solutions/overload_solution.cpp") }}
</div>
</li>


<li>
Using the above example, how could we further improve the clarity of the code with function templates?
<div class="answer">
  {{ include_code("solutions/template_solution.cpp") }}
</div>
</li>




<li>
What is the relationship between containers, iterators, and algorithms?<br />
Why is this relationship so important, and how does it help us as programmers<br >
How does this relate to the DRY (don't repeat yourself) principle?
  <div class="answer">
    Each container defines an iterator. Iterators act as an API which is used by algorithms. The algorithms, despite knowing nothing about the containers, are able to access them through zero-overhead abstractions through iterators.<br/>
    The relationship is very important, since it allows us to write generic code that doesn't need to be rewritten and retested for each different type. It also means that we can swap out types without the need to make many changes.<br/>
    It relates to the DRY principle in that we need to write m Containers + n algorithms, instead of m containers * n algorithms.
  </div>
</li>
{% endblock %}
