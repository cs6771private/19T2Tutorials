{% extends "templates/tut.html" %}
{% block questions %}

<li>
	<b>Section 1 Practice</b>
	Which part of this code is either a compile error, or bad style?
	{{ include_code("questions/1.cpp") }}
	<ol type="A">
		<li>A non-const member "radius_" cannot be initialised with a const parameter "r" in the constructor</li>
		<li>The initialiser list is not in the correct order</li>
		<li>The output operator for Lemon only takes in const Lemons, but we try and use it on a non-const Lemon object.</li>
		<li>Lemon cannot be constructed this way when the associated constructor is marked explicit</li>
	</ol>
	<div class="answer">
		B
	</div>
</li>

<li>
	<b>Section 1 Practice</b>
	Which of the following are NOT valid function overloads?

	<ol type="A">
		<li>
<pre>
bool foo(int a, int b);
bool foo(double a, double b);
</pre>
		</li>
		<li>
<pre>
bool foo(int a, int b);
double foo(int c, int d);
</pre>
		</li>
		<li>
<pre>
bool foo(int a, int b);
double foo(int c, double d);
</pre>
		</li>
		<li>
<pre>
int foo(char* a, char* b);
int foo(std::string a, std::string b);
</pre>
		</li>
	</ol>
	<div class="answer">
		B - can't distinguish by return type
	</div>
</li>


<li>
	<b>Section 1 Practice</b>
	Define "iterator" in the context of C++ STL

	<ol type="A">
		<li>The operator ++ used as either pre-increment or post-increment</li>
		<li>A variable used in for-loops (typically called "i") used to keep track of the index of an item during a loop iteration</li>
		<li>An abstraction of a pointer that represents a container in a linear form</li>
		<li>A pair of functions (usually begin() and end()) used by a container</li>
	</ol>
	<div class="answer">
		C
	</div>
</li>


<li>
	<b>Section 1 Practice</b>
	Which of the following is NOT a major reason why we prefer references over pointers in many instances?

	<ol type="A">
		<li>References often require less syntatic changes (e.g. no explicit deferencing require to get value) than pointers</li>
		<li>References cannot be set to null, unlike pointers</li>
		<li>References use less memory than pointers</li>
	</ol>
	<div class="answer">
		C - references do not use less memory than pointers
	</div>
</li>

<li>
	<b>Section 1 Practice</b>
	Observe the following code
<pre>void foo(const int& a) { std::cout << a; }
int i = 3;
foo(5); // usage 1
foo(i); // usage 2

int j = std::move(i);
foo(j); // usage 3
</pre>

	In each of the following 3 usages, is the call argument an lvalue or an value?

	<ol type="A">
		<li>Usage1=rvalue, Usage2=lvalue, Usage3=lvalue</li>
		<li>Usage1=lvalue, Usage2=lvalue, Usage3=lvalue</li>
		<li>Usage1=lvalue, Usage2=rvalue, Usage3=rvalue</li>
		<li>Usage1=rvalue, Usage2=rvalue, Usage3=lvalue</li>
		<li>Usage1=rvalue, Usage2=rvalue, Usage3=rvalue</li>
	</ol>
	<div class="answer">
		A
	</div>
</li>

<!--

	<li>
	<b>Section 1 Practice</b>
	multiple catches & rethrow - what does it output?

	<ol type="A">
		<li></li>
		<li></li>
		<li></li>
		<li></li>
	</ol>
	<div class="answer">
	</div>
</li>

<li>
	<b>Section 1 Practice</b>
	Variadic templates, what is the output?

	<ol type="A">
		<li></li>
		<li></li>
		<li></li>
		<li></li>
	</ol>
	<div class="answer">
	</div>
</li>



<li>
	<b>Section 1 Practice</b>
	Lambda usage answer

	<ol type="A">
		<li></li>
		<li></li>
		<li></li>
		<li></li>
	</ol>
	<div class="answer">
	</div>
</li>

-->

<li>
	<b>Section 1 Practice</b>

<pre>class Foo {
 public:
  Foo() : Foo(5) {}
  Foo(int var) : var_{var} {}
 private:
  int var_;
}
</pre>

	What is the term we use to refer to the function Foo() in class Foo?

	<ol type="A">
		<li>Delegating Constructor</li>
		<li>Delegating Assignment</li>
		<li>Polymorphic Constructor</li>
		<li>Polymorphic Assignment</li>
	</ol>
	<div class="answer">
		A
	</div>
</li>


<li>
	<b>Section 2 Practice</b>
	(1 mark) What is static polymorphism (i.e. templates)? Why do we use them/it?

	<div class="answer">
		Static polymorphism / templates are a form of generic programming that allow us to define types and operations that provide functionality independent of the the underlying type they operate on. They allow us to provide the same capability for a range of "generic" types without redefining code. (Note, a typical answer may be around 50-75% the length of this one. This is just longer to provide the full explanation).
	</div>

</li>

<li>
	<b>Section 2 Practice</b>
	(2 mark) What are the 3 components of the STL? What is a benefit of using the STL?

	<div class="answer">
		(1). Iterators, Containers, Algorithms.

		(2). Containers not needing to know about algorithms; algorithms not needing to know about iterators
	</div>

</li>

<!--

<li>
	<b>Section 3 Practice</b>
	add a non-type parameter to the findmin function (6.1.4.2)

	<ol type="A">
		<li></li>
		<li></li>
		<li></li>
		<li></li>
	</ol>
	<div class="answer">
	</div>
</li>-->

{% endblock %}
